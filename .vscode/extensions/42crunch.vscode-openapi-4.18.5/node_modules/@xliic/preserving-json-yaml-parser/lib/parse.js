"use strict";
/*
 Copyright (c) 42Crunch Ltd. All rights reserved.
 Licensed under the GNU Affero General Public License version 3. See LICENSE.txt in the project root for license information.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseYaml = exports.parseJson = void 0;
const yaml_1 = require("./visit/yaml");
const json_1 = require("./visit/json");
const preserve_1 = require("./preserve");
const json_parser_1 = require("./json-parser");
const json = require("jsonc-parser");
const yaml = require("yaml-language-server-parser");
const schema_1 = require("yaml-language-server-parser/dist/src/schema");
const type_1 = require("yaml-language-server-parser/dist/src/type");
const DEFAULT_SAFE_SCHEMA = require("yaml-language-server-parser/dist/src/schema/default_safe");
function extendedErrorToMessage(error) {
    if (error.extendedError) {
        if (error.extendedError === 1 /* ExtendedErrorCode.DuplicateKey */) {
            return "DuplicateKey";
        }
        return "<unknown ExtendedErrorCode>";
    }
    return json.printParseErrorCode(error.error);
}
function parseJson(text) {
    const parseErrors = [];
    const node = (0, json_parser_1.parseTree)(text, parseErrors, {
        disallowComments: true,
        allowTrailingComma: false,
        allowEmptyContent: false,
    });
    const normalizedErrors = parseErrors.map((error) => ({
        message: extendedErrorToMessage(error),
        offset: error.offset,
        length: error.length,
    }));
    if (node) {
        const parsed = runvisitor(json_1.visitJson, node);
        return [parsed, normalizedErrors];
    }
    return [undefined, normalizedErrors];
}
exports.parseJson = parseJson;
function parseYaml(text, customTags) {
    const documents = [];
    yaml.loadAll(text, (document) => {
        documents.push(document);
    }, { schema: createSchema(customTags) });
    if (documents.length !== 1) {
        return [undefined, []];
    }
    const normalizedErrors = documents[0].errors.map((error) => ({
        message: error.message,
        offset: error.mark ? error.mark.position : 0,
    }));
    if (documents[0]) {
        const parsed = runvisitor(yaml_1.visitYaml, documents[0]);
        return [parsed, normalizedErrors];
    }
    return [undefined, normalizedErrors];
}
exports.parseYaml = parseYaml;
function createSchema(customTags) {
    if (!customTags) {
        return DEFAULT_SAFE_SCHEMA;
    }
    const types = Object.entries(customTags).map(([key, value]) => new type_1.Type(key, { kind: value }));
    return schema_1.Schema.create(DEFAULT_SAFE_SCHEMA, types);
}
function runvisitor(visit, root) {
    var _a;
    let container = {};
    const stack = [container];
    visit(null, "fakeroot", root, {
        onObjectStart: (parent, key, value, location) => {
            if (location) {
                (0, preserve_1.setPreservedLocation)(container, key, location);
            }
            stack.push(container);
            container = container[key] = {};
        },
        onObjectEnd: () => {
            container = stack.pop();
        },
        onArrayStart: (parent, key, value, location) => {
            if (location) {
                (0, preserve_1.setPreservedLocation)(container, key, location);
            }
            stack.push(container);
            container = container[key] = [];
        },
        onArrayEnd: () => {
            container = stack.pop();
        },
        onValue: (parent, key, value, raw, location) => {
            container[key] = value;
            if (typeof value === "number" && raw !== undefined) {
                (0, preserve_1.setPreservedValue)(container, key, raw);
            }
            if (location) {
                (0, preserve_1.setPreservedLocation)(container, key, location);
            }
        },
    });
    if (typeof stack[0].fakeroot !== "object") {
        return undefined;
    }
    const range = (_a = (0, preserve_1.getPreservedLocation)(stack[0], "fakeroot")) === null || _a === void 0 ? void 0 : _a.value;
    (0, preserve_1.setPreservedRootRange)(stack[0].fakeroot, range);
    return stack[0].fakeroot;
}
