"use strict";
/*
 Copyright (c) 42Crunch Ltd. All rights reserved.
 Licensed under the GNU Affero General Public License version 3. See LICENSE.txt in the project root for license information.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitYaml = void 0;
const yaml_language_server_parser_1 = require("yaml-language-server-parser");
function visitYaml(parent, key, node, visitor) {
    const location = getLocation(parent, node);
    // the case for YAML which looks like this ```foo:``` and is similar to ```foo: null```
    // TODO maybe look into checking value before calling visitYaml() in previous
    // iteration and injecting a YAMLNode with proper offsets
    if (node === undefined || node === null) {
        visitor.onValue(parent, key, node, undefined, location);
        return;
    }
    if (node.kind === yaml_language_server_parser_1.Kind.MAP) {
        visitor.onObjectStart(parent, key, node, location);
        for (const mapping of node.mappings) {
            visitYaml(mapping, mapping.key.value, mapping.value, visitor);
        }
        visitor.onObjectEnd();
    }
    else if (node.kind === yaml_language_server_parser_1.Kind.SEQ) {
        visitor.onArrayStart(parent, key, node, location);
        node.items.forEach((value, index) => {
            visitYaml(node, index, value, visitor);
        });
        visitor.onArrayEnd();
    }
    else if (node.kind === yaml_language_server_parser_1.Kind.ANCHOR_REF) {
        // TODO figure out what to do with location data,
        // perhaps location data should not be saved in this case
        visitYaml(parent, key, node.value, visitor);
    }
    else if (node.kind === yaml_language_server_parser_1.Kind.MAPPING) {
        // this should not happen normally, but node.kind === Kind.MAPPING can be passed
        // as root, so we just walk it's contents
        visitYaml(parent, key, node.value, visitor);
    }
    else if (node.kind === yaml_language_server_parser_1.Kind.SCALAR) {
        const [type, value] = parseYamlScalar(node);
        const text = reserializeYamlValue(type, node.value, value);
        visitor.onValue(parent, key, value, text, location);
    }
}
exports.visitYaml = visitYaml;
// TODO honor YAML JSON mode
function parseYamlScalar(node) {
    const type = (0, yaml_language_server_parser_1.determineScalarType)(node);
    if (type === yaml_language_server_parser_1.ScalarType.int) {
        return [type, (0, yaml_language_server_parser_1.parseYamlInteger)(node.value)];
    }
    else if (type === yaml_language_server_parser_1.ScalarType.float) {
        return [type, (0, yaml_language_server_parser_1.parseYamlFloat)(node.value)];
    }
    else if (type === yaml_language_server_parser_1.ScalarType.bool) {
        return [type, (0, yaml_language_server_parser_1.parseYamlBoolean)(node.value)];
    }
    else if (type == yaml_language_server_parser_1.ScalarType.null) {
        return [type, null];
    }
    else {
        return [type, node.value];
    }
}
function getLocation(parent, node) {
    // key location is known for childen of MAPPING nodes
    const key = parent && parent.kind === yaml_language_server_parser_1.Kind.MAPPING
        ? { start: parent.key.startPosition, end: parent.key.endPosition }
        : undefined;
    if (node) {
        // normal case, non-null node
        return { key, value: { start: node.startPosition, end: node.endPosition } };
    }
    else if (parent && parent.kind === yaml_language_server_parser_1.Kind.MAPPING) {
        // for null nodes with known parent of type MAPPING
        // value location is a zero-width space after the end of the key
        return { key, value: { start: parent.key.endPosition, end: parent.key.endPosition } };
    }
    else {
        return { key, value: { start: 0, end: 0 } };
    }
}
function reserializeYamlValue(type, text, value) {
    if (type === yaml_language_server_parser_1.ScalarType.int) {
        return reserializeYamlInt(text);
    }
    if (type === yaml_language_server_parser_1.ScalarType.float) {
        return reserializeYamlFloat(value);
    }
    return text;
}
function reserializeYamlInt(value) {
    if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
    }
    let sign = BigInt(1);
    if (value[0] === "-" || value[0] === "+") {
        if (value[0] === "-")
            sign = BigInt(-1);
        value = value.slice(1);
    }
    const bigInt = sign * BigInt(value);
    return bigInt.toString();
}
function reserializeYamlFloat(value) {
    const serialized = JSON.stringify(value);
    if (serialized.includes("null") ||
        serialized.includes("e") ||
        serialized.includes("E") ||
        serialized.includes(".")) {
        return serialized;
    }
    return serialized + ".0";
}
