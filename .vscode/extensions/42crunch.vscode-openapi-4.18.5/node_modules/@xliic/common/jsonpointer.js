"use strict";
/*
 Copyright (c) 42Crunch Ltd. All rights reserved.
 Licensed under the GNU Affero General Public License version 3. See LICENSE.txt in the project root for license information.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.find = exports.findByPath = exports.parseJsonPointer = void 0;
function parseJsonPointer(pointer) {
    const hasExcape = /~/;
    const escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
        switch (m) {
            case "~1":
                return "/";
            case "~0":
                return "~";
        }
        throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
        if (!hasExcape.test(str)) {
            return str;
        }
        return str.replace(escapeMatcher, escapeReplacer);
    }
    return pointer.split("/").slice(1).map(untilde).map(decodeURIComponent);
}
exports.parseJsonPointer = parseJsonPointer;
function findByPath(document, path) {
    let current = document;
    for (const segment of path) {
        if (typeof current === "object" && current !== null) {
            if (Array.isArray(current)) {
                const index = parseInt(segment, 10);
                if (isNaN(index)) {
                    return undefined;
                }
                current = current[index];
            }
            else if (current.hasOwnProperty(segment)) {
                current = current[segment];
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }
    return current;
}
exports.findByPath = findByPath;
function find(document, pointer) {
    if (Array.isArray(pointer)) {
        return findByPath(document, pointer);
    }
    return findByPath(document, parseJsonPointer(pointer));
}
exports.find = find;
//# sourceMappingURL=jsonpointer.js.map