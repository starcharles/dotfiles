"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findLocationForJsonPointer = exports.findLocationForPath = exports.findNodeAtOffset = void 0;
const preserve_1 = require("./preserve");
const jsonpointer_1 = require("./jsonpointer");
function inRange(range, offset) {
    return offset >= range.start && offset <= range.end;
}
function findNodeAtOffset(root, offset) {
    const rootLocation = { value: (0, preserve_1.getPreservedRootRange)(root) };
    return findNodeAtOffsetImpl(root, offset, [], rootLocation);
}
exports.findNodeAtOffset = findNodeAtOffset;
function findNodeAtOffsetImpl(root, offset, path, location) {
    const keys = Array.isArray(root) ? root.keys() : Object.keys(root);
    for (const key of keys) {
        const location = (0, preserve_1.getPreservedLocation)(root, key);
        if (location && inRange(location.value, offset)) {
            const value = root[key];
            path.push(key);
            if (value !== null && typeof value === "object") {
                return findNodeAtOffsetImpl(value, offset, path, location);
            }
            else {
                return [value, path, location];
            }
        }
    }
    return [root, path, location]; // root is a container if offset is not found
}
function findLocationForPath(root, path) {
    if (path.length === 0) {
        // special case "" pointing to the root
        const range = (0, preserve_1.getPreservedRootRange)(root);
        return { value: range };
    }
    let current = root;
    let i = 0;
    while (i < path.length - 1 && current) {
        current = current[path[i]];
        i++;
    }
    if (current) {
        return (0, preserve_1.getPreservedLocation)(current, path[i]);
    }
}
exports.findLocationForPath = findLocationForPath;
function findLocationForJsonPointer(root, jsonPointer) {
    return findLocationForPath(root, (0, jsonpointer_1.parseJsonPointer)(jsonPointer));
}
exports.findLocationForJsonPointer = findLocationForJsonPointer;
