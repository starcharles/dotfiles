"use strict";
/*
 Copyright (c) 42Crunch Ltd. All rights reserved.
 Licensed under the GNU Affero General Public License version 3. See LICENSE.txt in the project root for license information.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTree = void 0;
const jsonc_parser_1 = require("jsonc-parser");
var ParseOptions;
(function (ParseOptions) {
    ParseOptions.DEFAULT = {
        allowTrailingComma: false,
    };
})(ParseOptions || (ParseOptions = {}));
function getNodeType(value) {
    switch (typeof value) {
        case "boolean":
            return "boolean";
        case "number":
            return "number";
        case "string":
            return "string";
        case "object": {
            if (!value) {
                return "null";
            }
            else if (Array.isArray(value)) {
                return "array";
            }
            return "object";
        }
        default:
            return "null";
    }
}
function findDuplicateKeys(children) {
    const duplicates = [];
    for (let i = 0; i < children.length; i++) {
        const current = children[i];
        if (current.type === "property") {
            for (let j = 0; j < children.length; j++) {
                const other = children[j];
                if (other.type === "property" &&
                    current.children[0].value === other.children[0].value &&
                    i !== j) {
                    duplicates.push(children[i].children[0]);
                }
            }
        }
    }
    return duplicates;
}
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
    let currentParent = {
        type: "array",
        offset: -1,
        length: -1,
        children: [],
        parent: undefined,
    }; // artificial root
    function ensurePropertyComplete(endOffset) {
        if (currentParent.type === "property") {
            currentParent.length = endOffset - currentParent.offset;
            currentParent = currentParent.parent;
        }
    }
    function onValue(valueNode) {
        currentParent.children.push(valueNode);
        return valueNode;
    }
    const visitor = {
        onObjectBegin: (offset) => {
            currentParent = onValue({
                type: "object",
                offset,
                length: -1,
                parent: currentParent,
                children: [],
            });
        },
        onObjectProperty: (name, offset, length) => {
            currentParent = onValue({
                type: "property",
                offset,
                length: -1,
                parent: currentParent,
                children: [],
            });
            currentParent.children.push({
                type: "string",
                value: name,
                offset,
                length,
                parent: currentParent,
            });
        },
        onObjectEnd: (offset, length) => {
            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete
            if (currentParent.type === "object" &&
                currentParent.children &&
                currentParent.children.length > 1) {
                // for objects with more than 1 property try to find any duplicate keys
                const keys = findDuplicateKeys(currentParent.children);
                for (const { offset, length } of keys) {
                    errors.push({
                        error: 0,
                        extendedError: 1 /* ExtendedErrorCode.DuplicateKey */,
                        offset,
                        length,
                    });
                }
            }
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onArrayBegin: (offset, length) => {
            currentParent = onValue({
                type: "array",
                offset,
                length: -1,
                parent: currentParent,
                children: [],
            });
        },
        onArrayEnd: (offset, length) => {
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onLiteralValue: (value, offset, length) => {
            onValue({
                type: getNodeType(value),
                offset,
                length,
                parent: currentParent,
                value,
                rawValue: text.substring(offset, offset + length),
            });
            ensurePropertyComplete(offset + length);
        },
        onSeparator: (sep, offset, length) => {
            if (currentParent.type === "property") {
                if (sep === ":") {
                    currentParent.colonOffset = offset;
                }
                else if (sep === ",") {
                    ensurePropertyComplete(offset);
                }
            }
        },
        onError: (error, offset, length) => {
            errors.push({ error, offset, length });
        },
    };
    (0, jsonc_parser_1.visit)(text, visitor, options);
    const result = currentParent.children[0];
    if (result) {
        delete result.parent;
    }
    return result;
}
exports.parseTree = parseTree;
